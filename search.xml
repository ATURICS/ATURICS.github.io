<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「题解」[NOI2012]迷失游乐园]]></title>
    <url>%2F2019%2F08%2F20%2F%5BNOI2012%5Dlost-amusement-park%2F</url>
    <content type="text"><![CDATA[什么逛公园啊游乐园啊，一看就没好事。 $Description$给定一棵树或基环树，您可以以任意点作为起点，等概率走到与之相连的任意未访问过的点。求路径的期望长度。 [$Solution$](https://www.luogu.org/blog/emptyset/solution-p2081 )$Talk\;is\;Cheap...$]]></content>
      <tags>
        <tag>基环树</tag>
        <tag>dp</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「学习笔记」基环树]]></title>
    <url>%2F2019%2F08%2F20%2FBRTStudyAccount%2F</url>
    <content type="text"><![CDATA[$Recommend$基环树学习笔记-$cly$_$none$：写得非常清晰漂亮。 $Find\;the\;Loop$该代码可以找二元环。 $code\;by\;$$Gion$ 12345678910111213141516171819vector&lt;int&gt; G[MAXN]; //基环树int fa[MAXN]; //dfs时的父亲int dfn[MAXN], idx; //访问的时间int loop[MAXN], cnt; //环void get_loop(int u) &#123; dfn[u] = ++ idx; for (int i = 0; i &lt; G[u].size(); i ++) &#123; int v = G[u][i]; if(v == fa[u]) continue ; if(dfn[v]) &#123;//v在环上 if(dfn[v] &lt; dfn[u]) continue ;//v已经被统计了 loop[++ cnt] = v;//环在u的子树上 for ( ; v != u; v = fa[v]) loop[++ cnt] = fa[v]; &#125; else fa[v] = u, get_loop(v); &#125;&#125; $Examples$ [ZJOI 2008]骑士$Description$基环树版「没有上司的舞会」。 $Solution$给出两种做法。 问题要求求解的是一个基环树森林。但由于可能存在重边，森林中可能存在树，应该是要考虑进去的。 先以没有上司的舞会的方式处理环的子树($f[i][0/1]$)，再处理环。 由于第一个点和最后一个点不能都选，所以在统计答案时要多加一维，表示1号点选不选。 $g[i][0/1][0/1]$表示环上的第i个点，1号点和i号点是否选择时，得到的最优答案。 再以没有上司的舞会的方式处理就可以了。 $Warning:$可以看出$g[2][1][1]$和$g[1][1][0]$之类是不存在的状态，因此要用到它的状态都要预处理好（$g[1-3]$）。 dfs找出环上的任意两个点$u,v$，强行断开$(u,v)$。由于可能存在重边，要暴力特判。 以它们为根各做一次树形dp，答案取$max(f[u][0],f[v][0])$ 两种做法的本质都是断边，但第二种实现较为容易。 给出第一种的$90pts$代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;cstdio&gt;#include&lt;cstring&gt;#define ll long longconst int MAXN = 1e6 + 10;int idx = 0, tot = 0, cnt = 0, N;int Loop[MAXN], dfn[MAXN] = &#123;0&#125;, h[MAXN], fa[MAXN], val[MAXN];ll g[MAXN][2][2], f[MAXN][2] = &#123;0&#125;;ll Ans = 0;struct E&#123; int t, nxt;&#125;Ed[MAXN &lt;&lt; 1];ll max(ll x, ll y)&#123;return x &gt; y ? x : y;&#125;int readint()&#123; int ret = 0; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') ch = getchar(); for (; ch &lt;= '9' &amp;&amp; ch &gt;= '0'; ch = getchar()) ret = ret * 10 + ch - 48; return ret;&#125;void Get_Loop(int u)&#123; dfn[u] = ++idx; for (int i = h[u]; i; i = Ed[i].nxt) &#123; int v = Ed[i].t; if (v == fa[u]) continue; if (dfn[v]) &#123; if (dfn[v] &lt; dfn[u]) continue; Loop[++tot] = v; for (; v != u; v = fa[v]) Loop[++tot] = fa[v]; &#125; else &#123;fa[v] = u; Get_Loop(v);&#125; &#125;&#125;void dfs(int u, int fa)&#123; f[u][1] = (ll)val[u]; for (int i = h[u]; i; i = Ed[i].nxt) &#123; int v = Ed[i].t; if (v == fa) continue; dfs(v, u); f[u][0] += max(f[v][0], f[v][1]); f[u][1] += f[v][0]; &#125;&#125;void Get_F(int u)&#123; f[Loop[u]][1] = (ll)val[Loop[u]]; for (int i = h[Loop[u]]; i; i = Ed[i].nxt) &#123; int v = Ed[i].t; if (v == Loop[u - 1] || v == Loop[u + 1]) continue; dfs(v, Loop[u]); f[Loop[u]][0] += max(f[v][0], f[v][1]); f[Loop[u]][1] += f[v][0]; &#125;&#125;void Dp()&#123; memset(g, 0, sizeof(g)); Loop[0] = Loop[tot]; Loop[tot + 1] = Loop[1]; Get_F(1), Get_F(2), Get_F(3); for (int i = 0; i &lt;= 1; i++) for (int j = 0; j &lt;= 1; j++) g[2][i][j] = f[Loop[1]][i] + f[Loop[2]][j]; g[2][1][1] = 0; g[3][0][0] = max(g[2][0][1], g[2][0][0]) + f[Loop[3]][0]; g[3][0][1] = g[2][0][0] + f[Loop[3]][1]; g[3][1][0] = g[2][1][0] + f[Loop[3]][0]; g[3][1][1] = g[2][1][0] + f[Loop[3]][1]; for (int u = 4; u &lt;= tot; u++) &#123; Get_F(u); for (int i = 0; i &lt;= 1; i++) &#123; g[u][i][0] = max(g[u - 1][i][0], g[u - 1][i][1]) + f[Loop[u]][0]; g[u][i][1] = g[u - 1][i][0] + f[Loop[u]][1]; &#125; &#125; Ans += max(g[tot][0][0], max(g[tot][0][1], g[tot][1][0]));&#125;void AddEdge(int f, int t)&#123; Ed[++cnt].t = t, Ed[cnt].nxt = h[f]; h[f] = cnt; Ed[++cnt].t = f, Ed[cnt].nxt = h[t]; h[t] = cnt;&#125;int main()&#123; freopen("Brienne.in", "r", stdin); N = readint(); for (int i = 1; i &lt;= N; i++) &#123;val[i] = readint(); int t = readint(); AddEdge(i, t);&#125; for (int i = 1; i &lt;= N; i++) if (!dfn[i]) &#123; memset(Loop, 0, sizeof(Loop)); tot = 0; fa[i] = -1; Get_Loop(i); if (!tot) &#123;dfs(i, -1); Ans += max(f[i][0], f[i][1]);&#125; else Dp(); &#125; printf("%lld", Ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[一些好用的软件/网址推荐!]]></title>
    <url>%2F2019%2F08%2F15%2Frecommend%2F</url>
    <content type="text"><![CDATA[软件1.$vscode$自从拥有了它，我果断抛弃了$Dev$。 但它不带编译环境，有点麻烦。 c++编译环境-$tangming$ 它的高亮是真的很漂亮，主题也非常多，可以在扩展商店下载。 冰与火之歌$Winter\;is\;coming$ 哈利波特$Hogwarts$都贼靓！ 原著党蠢蠢欲动 下面是史上最骚$Nebula$主题的演示 $2.X-Mind$简洁大气的思维导图制作软件。 正版要付费的。 $3.Notability$$Mac$笔记推介 这个记笔记绝佳。但本人是手写党，不太爱这个。 其实是太贵了 $4.Typora$一款达到了简洁的极高境界的Markdown编辑器。 编辑完回车即可实时查看效果。 网址$1.LibreOJ$页面简洁，还可以无限下数据某咕该学学这个 $2.Github\;And\;its\;Blog$一介凡人开发不了项目，但github的博客搭配hexo食用，是拥有个人网站最经济实惠的方式。 主题推荐使用NexT的Gemini。 下面推荐几个教程。 hexo博客搭建指北-$ouuan$ hexo史上最全搭建教程-$zjufangzh$]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo一路坑]]></title>
    <url>%2F2019%2F08%2F15%2FHexoFixed%2F</url>
    <content type="text"><![CDATA[$Prologue$2019.8.18，我的博客正式搭建完成（基础功能和我喜欢的美化基本上都有了。） 中间出过的锅也不少，但结局也还算圆满。 将一路踩过的坑，记述于此。 $Recommend$$hexo$史上最全搭建教程-$zjufangzh$ $hexo$博客搭建指北-$ouuan$ $1.nodejs:\;command\;not\;found$调了一下环境变量。 用户变量Path改为 D:\Program Files\nodejs\node_global\ 或者C:\Users\dguser\Desktop\你的博客文件夹\node_modules.bin 或许两个都要 $2.hexo\;sth$一输入和hexo有关的命令就会输出这个 1234567891011121314151617181920C:\Users\dguser\Desktop\myBlog\ATURICS.github.io\node_modules\nanomatch\index.js:243 nanomatch.every = ftn tion(list,peUdgrns$ Ottioos &#123;^SyntaxError: Invalid or unexpected tokenat Module._compile (internal/modules/cjs/loader.js:723:23)at Object.Module._extensions..js (internal/modules/cjs/loader.js:789:10)at Module.load (internal/modules/cjs/loader.js:653:32)at tryModuleLoad (internal/modules/cjs/loader.js:593:12)at Function.Module._load (internal/modules/cjs/loader.js:585:3)at Module.require (internal/modules/cjs/loader.js:692:17)at require (internal/modules/cjs/helpers.js:25:18)at Object. (C:\Users\dguser\Desktop\myBlog\ATURICS.github.io\node_modules\micromatch\lib\compilers.js:3:17)at Module._compile (internal/modules/cjs/loader.js:778:30)at Object.Module._extensions..js (internal/modules/cjs/loader.js:789:10)at Module.load (internal/modules/cjs/loader.js:653:32)at tryModuleLoad (internal/modules/cjs/loader.js:593:12)at Function.Module._load (internal/modules/cjs/loader.js:585:3)at Module.require (internal/modules/cjs/loader.js:692:17)at require (internal/modules/cjs/helpers.js:25:18)at Object. (C:\Users\dguser\Desktop\myBlog\ATURICS.github.io\node_modules\micromatch\index.js:16:17)` $AskLink1$ $CSDN$ 这些建议中的一个或多个解决了我的问题，在此衷心感谢。 $3.hexo\;d$$AskLink2$ 每次执行hexo d 12345678910111213141516171819INFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder...INFO Copying files from extend dirs...warning: LF will be replaced by CRLF in 2019/08/06/模拟退火（SA）学习笔记/index.html.The file will have its original line endings in your working directorywarning: LF will be replaced by CRLF in 2019/08/07/Hexo-NexT主题搭建笔记/index.html.The file will have its original line endings in your working directorywarning: LF will be replaced by CRLF in 2019/08/07/洛谷P3177 [HAOI2015]树上染色/index.html.The file will have its original line endings in your working directoryerror: inflate: data stream error (invalid distance too far back)error: corrupt loose object '5ec2e21b772abf9d4ee09bd363ad7f1f5ae4b035'fatal: loose object 5ec2e21b772abf9d4ee09bd363ad7f1f5ae4b035 (stored in .git/objects/5e/c2e21b772abf9d4ee09bd363ad7f1f5ae4b035) is corruptFATAL Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlError: Spawn failed at ChildProcess.&lt;anonymous&gt; (C:\Users\dguser\Desktop\myBlog\ATURICS.github.io\node_modules\hexo-util\lib\spawn.js:52:19) at ChildProcess.emit (events.js:198:13) at ChildProcess.cp.emit (C:\Users\dguser\Desktop\myBlog\ATURICS.github.io\node_modules\cross-spawn\lib\enoent.js:40:29) at Process.ChildProcess._handle.onexit (internal/child_process.js:248:12) 感谢code004大佬的耐心指导。 $4.Gitalk\;Error:Not\;Found$在上面的提问链接2中code004大佬也帮助解决了这个问题。 我的锅和别人不太一样 Gitalk那些要求你填的用户名都是上面那个加粗的。 我原来上面那个名字是八声甘州，后来改了就好了……反正把两个改成一样的保险。 $5.$图片无法显示网上的教程基本是没问题的 只是要你下的那个破烂插件不能用1.0.0版的 有人说的0.0.1，在next用就会让每篇博文的摘要只显示二十来个字，非常丑。 所以您install的时候别直接打hexo-asset-image 要写https://github.com/CodeFalling/hexo-asset-image.git 这样下的是0.0.5，可以正常显示图片。 $6.404$$AskLink3$ code004大佬再一次粗线……. 当时一激动，把repo直接删掉了。 后来deploy就一直有问题，触目惊心的红字伤透我的心。 只好重新init一个文件夹，把三样东西CtrlV过去。 1.主文件夹下的source 2.主文件夹下的config.yml 3.你选的那个主题整个儿搬过去就可以辣 $7.$乱码如果你为了装逼用了$English$ 将记事本-文件（F）-另存为（A）-编码（E）改为$UTF-8$ 中文即可正常显示。 $PostScript$我真的弄了很久，中间也有很崩溃很情绪化。 如果你对从未接触过的奇怪代码感到绝望，也请你不要放弃。 欢迎你来问我，在我的能力范围内，我乐意解答。 感谢code004大佬的帮助。]]></content>
  </entry>
  <entry>
    <title><![CDATA[「题解」 [HAOI2015]树上染色]]></title>
    <url>%2F2019%2F08%2F07%2F%5BHAOI2015%5DTreeDye%2F</url>
    <content type="text"><![CDATA[$Description$$Solution$分开计算每条边的贡献。 边对点产生贡献，当且仅当边的两端都有点。 于是对于$(u,fa)$，$u$的子树选中了$x$个点，我们可以分开计算白点和黑点的贡献$sum:$ $sum_{(u,fa)}=x(k-x)+(size[u]-x)(n-size[u]-k+x)$ $dp[fa][x]=dp[fa][x-y]+dp[v][y]+sum{(u,fa)}w{(u,fa)}$ 把$u$打成$y$水过两个点$QWQ$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;const int MAXN = 2010;long long dp[MAXN][MAXN];int siz[MAXN] = &#123;0&#125;, h[MAXN];int cnt = 0, N, K;struct E&#123; int t, val, nxt;&#125;Ed[2 * MAXN];void Add(int f, int t, int val)&#123;Ed[++cnt].t = t; Ed[cnt].nxt = h[f]; Ed[cnt].val = val; h[f] = cnt;&#125;void dfs(int k, int fa)&#123; siz[k] = 1; dp[k][0] = dp[k][1] = 0; for (int i = h[k]; i; i = Ed[i].nxt) &#123; int u = Ed[i].t; if (u == fa) continue; dfs(u, k); siz[k] += siz[u]; for (int x = std::min(siz[k], K); x &gt;= 0; x--) for (int y = 0; y &lt;= std::min(x, siz[u]); y++) &#123; if (dp[k][x - y] == -1) continue; long long sum = 1LL * (K - y) * y + 1LL * (siz[u] - y) * (N - siz[u] - K + y) ; dp[k][x] = std::max(dp[k][x - y] + dp[u][y] + sum * Ed[i].val, dp[k][x]); &#125; &#125;&#125;int rd()&#123; int ret = 0; char ch = getchar(); while(!isdigit(ch)) ch = getchar(); for(; isdigit(ch); ch = getchar()) ret = ret * 10 + (int)ch - 48; return ret;&#125;int main()&#123; freopen("Tarly.in", "r", stdin); N = rd(), K = rd(); memset(dp, -1, sizeof(dp)); for (int i = 1; i &lt; N; i++) &#123; int f = rd(), t = rd(), v = rd(); Add(f, t, v); Add(t, f, v); &#125; dfs(1, 0); printf("%lld\n", dp[1][K]); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[「学习笔记」模拟退火]]></title>
    <url>%2F2019%2F08%2F06%2FSAStudyAccount%2F</url>
    <content type="text"><![CDATA[引用：浅谈$SA-M$_$sea$ $SA$学习笔记-$99NL$ 退火流程：$1.$由上一次接受的解$pre$出发，随机得到一个可能解$x$。 $2.$若当前解优于最优解$ans$，覆盖最优解。 $3.$否则$x$将会以$exp(delta/T)$的概率成为下一次的$pre$。 $4.T*\Delta$降温。 $\Theta(???)$“一般降温系数 $\Delta$ 与 $1$ 的差减少一个数量级, 耗时大约多 $10$ 倍；$T_0$和$T_k$变化一个数量级, 耗时不会变化很大。” $by\;M$_$sea$ 实现细节$1.$降温系数取$[0.95,0.997]$左右。 $2.$如何生成新解？ 坐标系内：随机生成一个点，或者生成一个向量。 序列问题：$random\;shuffle$ 或者随机交换两个数。 网格问题：可以看做二维序列，每次交换两个格子即可。 $by\;M$_$sea$ $3.$如果想多跑几次…. 12MAX_TIME = 0.7~0.8while ((double)clock()/CLOCKS_PER_SEC&lt;MAX_TIME) SA(); 实测$P1337[JSOI2004]$平衡点 / 吊打$XXX$评测记录 $0.6-&gt;TLE$ $4.WA?$ 不同的$\Delta$、$T_0$、$T_k$甚至$srand()$和$SA$的次数都会影响到答案。 $by\;M$_$sea$ $About:srand()$ 你可以这样写： $srand((unsigned)time(NULL))/srand(19260817)$ 再$srand(rand())$几次。 例题$P1337[JSOI2004]$平衡点 / 吊打$XXX$ $1.$势能的计算：$len*w$（$len:$绳在桌面上的长度） 原理：绳子总长不变，$len$越大，物体越高。 $2.$横纵坐标的增量：$((rand() &lt;&lt; 1) - RAND$_$MAX) * T$ $((rand() &lt;&lt; 1) - RAND$$MAX)$得到介于$[-RAND$ $MAX,RAND$ _ $MAX-1]$之间的随机数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;ctime&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;const double eps = 1e-14, del = 0.992;const int MAXN = 1010;int N;double ansx, ansy, ans = 1e18;int x[MAXN], y[MAXN], w[MAXN];double calcEp(double nx, double ny)&#123; double ret = 0; for (int i = 1; i &lt;= N; i++) &#123; double dx = nx - x[i], dy = ny - y[i]; ret += sqrt(dx * dx + dy * dy) * (double)w[i]; &#125; return ret;&#125;void SA()&#123; double T = 1926, tx = ansx, ty = ansy; while (T &gt; eps) &#123; double nx = tx + ((rand() &lt;&lt; 1) - RAND_MAX) * T; double ny = ty + ((rand() &lt;&lt; 1) - RAND_MAX) * T; double c = calcEp(nx, ny); double d = c - ans; if (d &lt; eps) &#123;ansx = nx, ansy = ny; ans = c; tx = nx, ty = ny;&#125; else if (exp(-d / T) * RAND_MAX &gt; rand())&#123;tx = nx, ty = ny;&#125; T *= del; &#125;&#125;void calc()&#123; for (int i = 1; i &lt;= N; i++) ansx += x[i], ansy += y[i]; ansx /= N, ansy /= N; SA(); SA(); SA(); SA(); &#125;int main()&#123; srand(19260817); srand(rand()); scanf("%d", &amp;N); for (int i = 1; i &lt;= N; i++) scanf("%d%d%d", &amp;x[i], &amp;y[i], &amp;w[i]); calc(); printf("%.3lf %.3lf\n", ansx, ansy); return 0;&#125;]]></content>
  </entry>
</search>
