<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一些好用的软件/网址推荐!]]></title>
    <url>%2F2019%2F08%2F15%2Frecommend%2F</url>
    <content type="text"><![CDATA[软件1.$vscode$自从拥有了它，我果断抛弃了$Dev$。 但它不带编译环境，有点麻烦。 c++编译环境-$tangming$ 它的高亮是真的很漂亮，主题也非常多，可以在扩展商店下载。 冰与火之歌$Winter\;is\;coming$ 哈利波特$Hogwarts$都贼靓！ 原著党蠢蠢欲动 下面是史上最骚$Nebula$主题的演示 $2.X-Mind$简洁大气的思维导图制作软件。 正版要付费的。 $3.Notability$$Mac$笔记推介 这个记笔记绝佳。但本人是手写党，不太爱这个。 其实是太贵了 $4.Typora$一款达到了简洁的极高境界的Markdown编辑器。 编辑完回车即可实时查看效果。 网址$1.LibreOJ$页面简洁，还可以无限下数据某咕该学学这个 $2.Github\;And\;its\;Blog$一介凡人开发不了项目，但github的博客搭配hexo食用，是拥有个人网站最经济实惠的方式。 主题推荐使用NexT的Gemini。 下面推荐几个教程。 hexo博客搭建指北-$ouuan$ hexo史上最全搭建教程-$zjufangzh$]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo修复笔记]]></title>
    <url>%2F2019%2F08%2F15%2FHexoFixed%2F</url>
    <content type="text"><![CDATA[$Prologue$2019.8.18，我的博客正式搭建完成（基础功能和我喜欢的美化基本上都有了。） 中间出过的锅也不少，但结局也还算圆满。 将一路踩过的坑，记述于此。 $Recommend$$hexo$史上最全搭建教程-$zjufangzh$ $hexo$博客搭建指北-$ouuan$ $1.nodejs:\;command\;not\;found$调了一下环境变量。 用户变量Path改为 D:\Program Files\nodejs\node_global\ 或者C:\Users\dguser\Desktop\你的博客文件夹\node_modules.bin 或许两个都要 $2.hexo\;sth$一输入和hexo有关的命令就会输出这个 1234567891011121314151617181920C:\Users\dguser\Desktop\myBlog\ATURICS.github.io\node_modules\nanomatch\index.js:243 nanomatch.every = ftn tion(list,peUdgrns$ Ottioos &#123;^SyntaxError: Invalid or unexpected tokenat Module._compile (internal/modules/cjs/loader.js:723:23)at Object.Module._extensions..js (internal/modules/cjs/loader.js:789:10)at Module.load (internal/modules/cjs/loader.js:653:32)at tryModuleLoad (internal/modules/cjs/loader.js:593:12)at Function.Module._load (internal/modules/cjs/loader.js:585:3)at Module.require (internal/modules/cjs/loader.js:692:17)at require (internal/modules/cjs/helpers.js:25:18)at Object. (C:\Users\dguser\Desktop\myBlog\ATURICS.github.io\node_modules\micromatch\lib\compilers.js:3:17)at Module._compile (internal/modules/cjs/loader.js:778:30)at Object.Module._extensions..js (internal/modules/cjs/loader.js:789:10)at Module.load (internal/modules/cjs/loader.js:653:32)at tryModuleLoad (internal/modules/cjs/loader.js:593:12)at Function.Module._load (internal/modules/cjs/loader.js:585:3)at Module.require (internal/modules/cjs/loader.js:692:17)at require (internal/modules/cjs/helpers.js:25:18)at Object. (C:\Users\dguser\Desktop\myBlog\ATURICS.github.io\node_modules\micromatch\index.js:16:17)` $AskLink1$ $CSDN$ 这些建议中的一个或多个解决了我的问题，在此衷心感谢。 $3.hexo\;d$$AskLink2$ 每次执行hexo d 12345678910111213141516171819INFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder...INFO Copying files from extend dirs...warning: LF will be replaced by CRLF in 2019/08/06/模拟退火（SA）学习笔记/index.html.The file will have its original line endings in your working directorywarning: LF will be replaced by CRLF in 2019/08/07/Hexo-NexT主题搭建笔记/index.html.The file will have its original line endings in your working directorywarning: LF will be replaced by CRLF in 2019/08/07/洛谷P3177 [HAOI2015]树上染色/index.html.The file will have its original line endings in your working directoryerror: inflate: data stream error (invalid distance too far back)error: corrupt loose object '5ec2e21b772abf9d4ee09bd363ad7f1f5ae4b035'fatal: loose object 5ec2e21b772abf9d4ee09bd363ad7f1f5ae4b035 (stored in .git/objects/5e/c2e21b772abf9d4ee09bd363ad7f1f5ae4b035) is corruptFATAL Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlError: Spawn failed at ChildProcess.&lt;anonymous&gt; (C:\Users\dguser\Desktop\myBlog\ATURICS.github.io\node_modules\hexo-util\lib\spawn.js:52:19) at ChildProcess.emit (events.js:198:13) at ChildProcess.cp.emit (C:\Users\dguser\Desktop\myBlog\ATURICS.github.io\node_modules\cross-spawn\lib\enoent.js:40:29) at Process.ChildProcess._handle.onexit (internal/child_process.js:248:12) 感谢code004大佬的耐心指导。 $4.Gitalk\;Error:Not\;Found$在上面的提问链接2中code004大佬也帮助解决了这个问题。 我的锅和别人不太一样 Gitalk那些要求你填的用户名都是上面那个加粗的。 我原来上面那个名字是八声甘州，后来改了就好了……反正把两个改成一样的保险。 $5.$图片无法显示网上的教程基本是没问题的 只是要你下的那个破烂插件不能用1.0.0版的 有人说的0.0.1，在next用就会让每篇博文的摘要只显示二十来个字，非常丑。 所以您install的时候别直接打hexo-asset-image 要写https://github.com/CodeFalling/hexo-asset-image.git 这样下的是0.0.5，可以正常显示图片。 $6.404$$AskLink3$ code004大佬再一次粗线……. 当时一激动，把repo直接删掉了。 后来deploy就一直有问题，触目惊心的红字伤透我的心。 只好重新init一个文件夹，把三样东西CtrlV过去。 1.主文件夹下的source 2.主文件夹下的config.yml 3.你选的那个主题整个儿搬过去就可以辣 $7.$乱码如果你为了装逼用了$English$ 将记事本-文件（F）-另存为（A）-编码（E）改为$UTF-8$ 中文即可正常显示。 $PostScript$我真的弄了很久，中间也有很崩溃很情绪化。 如果你对从未接触过的奇怪代码感到绝望，也请你不要放弃。 欢迎你来问我，在我的能力范围内，我乐意解答。 感谢code004大佬的帮助。真的是很耐心的一个人。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test2019.8.7]]></title>
    <url>%2F2019%2F08%2F08%2FTest-2019-8-7%2F</url>
    <content type="text"><![CDATA[$Description$给出一个$01$矩阵，求次大全$1$矩阵。 $Solution$$20pts$ 暴力枚举矩形的左上角和右下角直接统计，$O(N^4)$ $30pts$ 枚举左上角和矩形长度，二分宽度统计, $O(N^3logN)$ $50pts$ 枚举左下角的行，统计对应行每一列往上最多可以走多少行。然后双指针移动确定左右边界，单调队列维护区间内往上走多走的行数的最小值，区间长乘以最小值即为矩形面积，$O(N^3)$ $100pts$ 预处理每个位置往上左右能够拓展的长度，然后自上而下统计每个为1的位置能够构成的矩形的最大值，具体参见代码，比较好理解，$O(N^2)$。 $Std$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std; const int N = 1e3+100; int n, m;int g[N][N];int u[N][N];int l[N][N];int r[N][N];int hh,ll,rr,bb;char str[N];int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i = 1; i &lt;= n; i++)&#123; scanf("%s",str+1); for(int j =1;j&lt;=m;j++ )&#123; if(str[j] == '1') g[i][j] = 1; else g[i][j] = 0; &#125; &#125; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) u[i][j] = l[i][j] = r[i][j] = 0; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(g[i][j] == 0) continue; u[i][j] = g[i-1][j] == 1 ? u[i-1][j] : i; l[i][j] = g[i][j-1] == 1 ? l[i][j-1] : j; &#125; for(int j = m; j &gt;= 1; j--)&#123; if(g[i][j] == 0) continue; r[i][j] = g[i][j+1] == 1 ? r[i][j+1] : j; &#125; &#125; int ans = 0; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(g[i][j] == 0) continue; if(g[i-1][j] == 1)&#123; l[i][j] = max(l[i][j], l[i-1][j]); r[i][j] = min(r[i][j], r[i-1][j]); &#125; if(ans&lt;(r[i][j]-l[i][j]+1)*(i-u[i][j]+1))&#123; hh = u[i][j] , bb =i; rr = r[i][j],ll=l[i][j]; ans = (r[i][j]-l[i][j]+1)*(i-u[i][j]+1); &#125; &#125; &#125; int ans2 = 0; ans2= max(ans2,(rr - ll) * (bb - hh + 1)); ans2= max(ans2,(rr - ll +1) * (bb - hh )); for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(g[i][j] == 0) continue; if(hh==u[i][j]&amp;&amp;bb==i&amp;&amp;ll==l[i][j]&amp;&amp;rr==r[i][j]) continue; if(ans2&lt;(r[i][j]-l[i][j]+1)*(i-u[i][j]+1))&#123; ans2=(r[i][j]-l[i][j]+1)*(i-u[i][j]+1); &#125; &#125; &#125; cout &lt;&lt; ans2 &lt;&lt; endl; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test2019.8.8]]></title>
    <url>%2F2019%2F08%2F08%2FTest2019-8-8%2F</url>
    <content type="text"><![CDATA[$P1$ 数列$Description$$F[n]=F[n / 2]+F[n / 3]+F[n / 5]+F[n / 7] (n&lt;=1e12)$ $Solution$$50pts$直接线性预处理。 $70pts$线性预处理1000万项，对于大于1000万的n，递归求解。 $100pts$：在递归的同时，用哈希记录之前计算的数值，每次递归到一个之前算过的数值，则直接使用，相当于记忆化搜索。 $Std$123456789101112131415161718192021222324252627282930#include&lt;cstdio&gt;#include&lt;map&gt;#define file(x) freopen(#x".in","r",stdin),freopen(#x".out","w",stdout);#define N 10000000#define LL long longusing namespace std;map&lt;LL,LL&gt; mp;int f[N];LL zxy(LL i)&#123; if (i&lt;10000000) return f[i]; if (mp[i]!=0) return mp[i]; mp[i]=zxy(i/2)+zxy(i/3)+zxy(i/5)+zxy(i/7); return mp[i];&#125;int main()&#123; file(G:/data9); int T; scanf("%d",&amp;T); LL n; f[0]=1; f[1]=1; for (int i=2;i&lt;N;i++) f[i]=f[i/2]+f[i/3]+f[i/5]+f[i/7]; while (T--) &#123; scanf("%lld",&amp;n); printf("%lld\n",zxy(n)); &#125;&#125; $P2$ 背包$Description$框架同$P1432$ 倒水问题 $C_aC_b$不互质，且$&lt;=1e9$ $Drop$：把其中一个书包里面的所有书拿出来。 $Add$：不断地往一个书包里面装书，直到达到书包的数量上限。 $Transfer$：把其中一个书包里的书尽量的装到另外一个书包里面，直到那个书包装不下书或者没有书可以放。 $Solution$$30pts$直接暴力搜索 $50pts$搜索，用背包当前装书的数量作为状态进行搜索，不搜索重复状态，复杂度$O(N^2)$ $100pts$首先，当$c&gt;a$且$c&gt;b$的时候，显然无法完成。然后我们考虑整体，书增加的方式只能通过往两个书包里面放书直到放满。所以如果可以使得一个数量达到$c$，那么一定有$ax+by=c$，根据裴蜀定理，只需要判断$gcd(a,b)$是否是$c$的因子即可。 然后考虑最小操作数。根据裴蜀定理，因为$c&lt;=max(a,b)$所以$x$和$y$肯定一正一负或者一正一零。我们不妨设$x&gt;0$，则最少操作数流程如下： $1.$给$A$加满书(对应增加一个$a$) $2.A$转移到$B$ $3.B$如果满，那么把所有的拿出来(对应减去一个$b$) $4.$如果$A$非空，那么重复$2-4$ $5.$从$1$开始重复整个过程，直到$A$或$B$中书的数量为$c$ 如果$c&gt;a$，则最终B里面会先有$c$的本书，因为$A$存不下，这种情况下$x$次$ADD$，$-y$次$Drop$，$x-y$次转移，总共$2x-2y$次操作。 如果$c&lt;=a$，假设$B$先有$c$本书，则$b&gt;=c$，又$c&lt;=max(a,b)$，所以$a$和至少一个等于$c$，此时操作数为$1$；假设$A$先有$c$本书，则有$x$次$ADD$，$x-y-1$次转移，$-y-1$次$Drop$。$Drop$是$-y-1$次是因为当发现$A$有$c$的时候，$B$虽然满了但是为了操作数少可以不拿出来。因此此时操作数为$2x-2y-2$次。 综上，我们要最小化$|x|+|y|$。用扩展欧几里得定理找到和$0$最近的两组$(x,y)$，然后比较即可。 $Std$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;LL gcd(LL a, LL b, LL &amp;x, LL &amp;y)&#123; if (b == 0) &#123; x = 1, y = 0; return a; &#125; LL q = gcd(b, a % b, y, x); y -= a / b * x; return q;&#125;int main()&#123; freopen("data.in", "r", stdin); freopen("data.out", "w", stdout); int T; cin &gt;&gt; T; while (T--) &#123; LL a, b, c, x, y; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int d = gcd(a, b, x, y); if (c &gt; a &amp;&amp; c &gt; b || c % d) &#123; cout &lt;&lt; 0 &lt;&lt; endl; continue; &#125; if (c == a || c == b) &#123; cout &lt;&lt; 1 &lt;&lt; endl; continue; &#125; if (y &gt; 0) swap(x, y), swap(a, b); LL a2 = a / d, b2 = b / d; x *= c / d, y *= c / d; LL k = x / b2; x -= k * b2, y += k * a2; LL res; if (c &gt; a) res = 2 * (x - y); else res = 2 * (x - y - 1); x -= b2, y += a2; if (c &gt; b) res = min(res, 2 * (y - x)); else res = min(res, 2 * (y - x - 1)); cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; $T3$ 战场$Description$求基环树上任意两点之间颜色数目为奇数的最大颜色数。 $Solution$$30pts$建图，对于每个询问暴力做。 $70pts$由于颜色数目小于等于$50$，所以我们考虑用一个$long long$变量表示某个颜色出现次数的奇偶性。基环树，我们可考虑看作两部分，一部分是环上的点，一部分是非环上的点。首先，我们找到环上的点并标记，然后以其中一个点作为起点计算前缀异或和$s[]$。 对于环上第$x$个点和第$y$个点$(y&gt;x)$的答案，我们假设环上有$m$个点，那么有两条路可以比较，一是直接$s[y]$^$s[x-1]$直接求区间异或和，而是多转一圈，那就是$s[m]$^$s[y-1]$^$s[x]$。比较两个哪个含$1$的位数多即可。 对于询问中存在不在环上的点的情况，我们对每个不在环上的点维护它距离它最近的环上点的距离。显然，如果环上的连接着除环上点以外的点，那么这些点一定构成一棵树，而这个环上的点就是树的根。所以，首先判断两个点是否在同一棵树下，即最近的环上点是否相同。如果相同，那么只有一种答案，就是树中两点直接路径。如果不同，那么可以分为三个部分，前两个部分是两个点分别到各自最近的环上点的异或和，第三部分就是两个环上点的两种异或和，比较一下大小即可。 对于环上的点，前缀异或和维护；对于非环上的点，树链剖分加树状数组维护。时间复杂度$O(NlogN)$。 $100pts$$bitset$ $Std$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include&lt;bits/stdc++.h&gt;#define clr(x,n) memset(x,0,sizeof(x[0])*(n+5))#define file(x) freopen(#x".in","r",stdin),freopen(#x".out","w",stdout)using namespace std;const int N = 5e5+10;namespace IO&#123; const int len=1e7;char buf[len];int sz,p; void begin()&#123;p=0;sz=fread(buf,1,len,stdin);&#125; inline bool read(int &amp;x) &#123; if (p==sz)return 0;int f=1,d=0;char s=buf[p++]; while(s&lt;'0'||s&gt;'9'&amp;&amp;p&lt;sz)&#123;if(s=='-') f=-1;s=buf[p++];&#125; while(s&gt;='0'&amp;&amp;s&lt;='9'&amp;&amp;p&lt;sz)&#123;d=d*10+s-'0';s=buf[p++];&#125; x=f*d; return p!=sz; &#125; inline void writeln(int x) &#123; if(x==0)&#123;putchar('0');putchar('\n');return;&#125; if(x&lt;0)putchar('-'),x=-x;int len=0,buf[20]; while(x)buf[len++]=x%10,x/=10;int i=len-1; while (i&gt;=0)&#123;putchar(buf[i--]+'0');&#125;putchar('\n');return; &#125;&#125;int lc[N],rc[N],top[N],size[N],son[N],fa[N],dep[N];int ls[N],on[N],f[N],id[N],hid[N],num;int n,m,tot,e;struct Edge&#123;int x,y,w,nxt;&#125; g[N&lt;&lt;1];inline void dfs1(int u,int d,int f)&#123; son[u]=0; dep[u]=d; size[u]=1; for(int i=ls[u];i;i=g[i].nxt) if (g[i].y!=f) &#123; fa[g[i].y]=u; dfs1(g[i].y,d+1,u); size[u]+=size[g[i].y]; if (size[g[i].y]&gt;size[son[u]]) son[u]=g[i].y; &#125;&#125;inline void dfs2(int u,int f)&#123; top[u]=f; lc[u]=++num; if (son[u]) dfs2(son[u],f); for(int i=ls[u];i;i=g[i].nxt) if (g[i].y!=son[u]&amp;&amp;g[i].y!=fa[u]) dfs2(g[i].y,g[i].y); rc[u]=num;&#125;inline int LCA(int u,int v)&#123; int tp1=top[u],tp2=top[v]; while (tp1!=tp2) &#123; if (dep[tp1]&lt;dep[tp2]) swap(tp1,tp2),swap(u,v); u=fa[tp1]; tp1=top[u]; &#125; if (dep[u]&gt;dep[v]) swap(u,v); return u;&#125;inline void addedge(int x,int y,int w)&#123;g[++e]=Edge&#123;x,y,w,ls[x]&#125;;ls[x]=e;&#125;struct BinaryIndexedTree&#123; bitset&lt;1001&gt; c[N]; inline int lowbit(int x)&#123;return x&amp;-x;&#125; inline void init(int n)&#123;memset(c,0,sizeof(c));&#125; inline void update(int x,bitset&lt;1001&gt; k)&#123;for(;x&lt;=n;x+=lowbit(x)) c[x]^=k;&#125; inline bitset&lt;1001&gt; getsum(int x)&#123;bitset&lt;1001&gt; ans;for(;x&gt;0;x-=lowbit(x))ans^=c[x];return ans;&#125;&#125; BIT[2];bool dfs(int x,int father,int y)&#123; for(int i=ls[x];i;i=g[i].nxt) &#123; if (g[i].y==father) continue; fa[g[i].y]=x; if (g[i].y==y) &#123; on[y]=1; for(int j=x;j!=0;j=fa[j]) on[j]=1; return 1; &#125; if (dfs(g[i].y,x,y)) return 1; &#125;&#125;inline int find(int x)&#123; return f[x]==x?x:f[x]=find(f[x]);&#125;inline void expand(int x,int fa,int ff) //对环上的每一个点拓展&#123; id[x]=ff; //id标记为对应的起点，即距离最近的环上点 for(int i=ls[x];i;i=g[i].nxt) &#123; if (on[g[i].y]||g[i].y==fa) continue; //只走非环上的点 bitset&lt;1001&gt; tmp; tmp.set(g[i].w); BIT[1].update(lc[g[i].y],tmp); //维护树状数组 BIT[1].update(rc[g[i].y]+1,tmp); expand(g[i].y,x,ff); &#125;&#125;inline void circle(int x,int fa,bitset&lt;1001&gt; dist) //对环上的点重标号，并且维护树状数组&#123; hid[x]=++tot; for(int i=ls[x];i;i=g[i].nxt) &#123; if (g[i].y==fa||!on[g[i].y]) continue; bitset&lt;1001&gt; tmp=dist; tmp.flip(g[i].w); BIT[0].update(tot+1,tmp); BIT[0].update(tot+2,tmp); circle(g[i].y,x,tmp); &#125;&#125;int main()&#123; file(G:/data0); IO::begin(); int root=1; bitset&lt;1001&gt; sum; IO::read(n); IO::read(m); for(int i=1;i&lt;=n;i++) f[i]=i; for(int i=1;i&lt;=n;i++) &#123; int x,y,w; IO::read(x); IO::read(y); IO::read(w); if (find(x)!=find(y)) //如果二者不连通，直接加 &#123; f[find(x)]=find(y); addedge(x,y,w); addedge(y,x,w); &#125; else //如果已经连通，说明找到了环，记下root &#123; //同时dfs遍历环上的点，标记为在环上 sum.set(w),dfs(root=x,0,y); g[++e]=Edge&#123;x,y,w,0&#125;; g[++e]=Edge&#123;y,x,w,0&#125;; &#125; &#125; dfs1(root,0,0); //树链剖分 dfs2(root,root); //标记每个点及其子树的编号范围lc和rc for(int i=1;i&lt;=n;i++) if (on[i]) expand(i,fa[i],i); //对于每一个环上的点进行拓展 circle(root,0,0); sum^=BIT[0].getsum(tot); //重标号环上的点 while(m--) &#123; int op,x,y; IO::read(op); IO::read(x); IO::read(y); if (op==0) &#123; x&lt;&lt;=1; int a=g[x].x,b=g[x].y; if (dep[a]&gt;dep[b]) swap(a,b); bitset&lt;1001&gt; tmp; tmp.set(g[x].w); tmp.flip(y); if (on[a]==1&amp;&amp;on[b]==1) //若两个点都在换上，那么修改树状数组0 &#123; if (dep[b]-dep[a]&lt;=1) BIT[0].update(hid[b],tmp); sum^=tmp; &#125; else &#123; //否则修改树状数组1 BIT[1].update(lc[b],tmp); BIT[1].update(rc[b]+1,tmp); &#125; g[x].w=y; &#125; else &#123; if (find(x)!=find(y)) &#123; puts("-1"); continue; &#125; if (dep[x]&gt;dep[y]) swap(x,y); if (id[x]!=id[y]) //距离最近的环上点不相同，则分为三部分 &#123; int l=min(hid[id[x]],hid[id[y]]); int r=max(hid[id[x]],hid[id[y]]); bitset&lt;1001&gt; tmp=BIT[0].getsum(r)^BIT[0].getsum(l); //环上点之间的距离 bitset&lt;1001&gt; a=BIT[1].getsum(lc[x]); //x距离其最近环上点的距离 bitset&lt;1001&gt; b=BIT[1].getsum(lc[y]); //y距离其最近的环上点的距离 a^=b^tmp; b=a^sum; IO::writeln((int)max(a.count(),b.count())); &#125; else &#123; bitset&lt;1001&gt; a=BIT[1].getsum(lc[x]); bitset&lt;1001&gt; b=BIT[1].getsum(lc[y]); a^=b; IO::writeln((int)a.count()); &#125; &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3177 [HAOI2015]树上染色]]></title>
    <url>%2F2019%2F08%2F07%2FP3177%20%5BHAOI2015%5DTreeDye%2F</url>
    <content type="text"><![CDATA[$Description$$Solution$分开计算每条边的贡献。 边对点产生贡献，当且仅当边的两端都有点。 于是对于$(u,fa)$，$u$的子树选中了$x$个点，我们可以分开计算白点和黑点的贡献$sum:$ $sum_{(u,fa)}=x(k-x)+(size[u]-x)(n-size[u]-k+x)$ $dp[fa][x]=dp[fa][x-y]+dp[v][y]+sum{(u,fa)}w{(u,fa)}$ 把$u$打成$y$水过两个点$QWQ$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;const int MAXN = 2010;long long dp[MAXN][MAXN];int siz[MAXN] = &#123;0&#125;, h[MAXN];int cnt = 0, N, K;struct E&#123; int t, val, nxt;&#125;Ed[2 * MAXN];void Add(int f, int t, int val)&#123;Ed[++cnt].t = t; Ed[cnt].nxt = h[f]; Ed[cnt].val = val; h[f] = cnt;&#125;void dfs(int k, int fa)&#123; siz[k] = 1; dp[k][0] = dp[k][1] = 0; for (int i = h[k]; i; i = Ed[i].nxt) &#123; int u = Ed[i].t; if (u == fa) continue; dfs(u, k); siz[k] += siz[u]; for (int x = std::min(siz[k], K); x &gt;= 0; x--) for (int y = 0; y &lt;= std::min(x, siz[u]); y++) &#123; if (dp[k][x - y] == -1) continue; long long sum = 1LL * (K - y) * y + 1LL * (siz[u] - y) * (N - siz[u] - K + y) ; dp[k][x] = std::max(dp[k][x - y] + dp[u][y] + sum * Ed[i].val, dp[k][x]); &#125; &#125;&#125;int rd()&#123; int ret = 0; char ch = getchar(); while(!isdigit(ch)) ch = getchar(); for(; isdigit(ch); ch = getchar()) ret = ret * 10 + (int)ch - 48; return ret;&#125;int main()&#123; freopen("Tarly.in", "r", stdin); N = rd(), K = rd(); memset(dp, -1, sizeof(dp)); for (int i = 1; i &lt; N; i++) &#123; int f = rd(), t = rd(), v = rd(); Add(f, t, v); Add(t, f, v); &#125; dfs(1, 0); printf("%lld\n", dp[1][K]); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[模拟退火（SA）学习笔记]]></title>
    <url>%2F2019%2F08%2F06%2FSAStudyAccount%2F</url>
    <content type="text"><![CDATA[引用：浅谈$SA-M$_$sea$ $SA$学习笔记-$99NL$ 退火流程：$1.$由上一次接受的解$pre$出发，随机得到一个可能解$x$。 $2.$若当前解优于最优解$ans$，覆盖最优解。 $3.$否则$x$将会以$exp(delta/T)$的概率成为下一次的$pre$。 $4.T*\Delta$降温。 $\Theta(???)$“一般降温系数 $\Delta$ 与 $1$ 的差减少一个数量级, 耗时大约多 $10$ 倍；$T_0$和$T_k$变化一个数量级, 耗时不会变化很大。” $by\;M$_$sea$ 实现细节$1.$降温系数取$[0.95,0.997]$左右。 $2.$如何生成新解？ 坐标系内：随机生成一个点，或者生成一个向量。 序列问题：$random\;shuffle$ 或者随机交换两个数。 网格问题：可以看做二维序列，每次交换两个格子即可。 $by\;M$_$sea$ $3.$如果想多跑几次…. 12MAX_TIME = 0.7~0.8while ((double)clock()/CLOCKS_PER_SEC&lt;MAX_TIME) SA(); 实测$P1337[JSOI2004]$平衡点 / 吊打$XXX$评测记录 $0.6-&gt;TLE$ $4.WA?$ 不同的$\Delta$、$T_0$、$T_k$甚至$srand()$和$SA$的次数都会影响到答案。 $by\;M$_$sea$ $About:srand()$ 你可以这样写： $srand((unsigned)time(NULL))/srand(19260817)$ 再$srand(rand())$几次。 例题$P1337[JSOI2004]$平衡点 / 吊打$XXX$ $1.$势能的计算：$len*w$（$len:$绳在桌面上的长度） 原理：绳子总长不变，$len$越大，物体越高。 $2.$横纵坐标的增量：$((rand() &lt;&lt; 1) - RAND$_$MAX) * T$ $((rand() &lt;&lt; 1) - RAND$$MAX)$得到介于$[-RAND$ $MAX,RAND$ _ $MAX-1]$之间的随机数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;ctime&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;const double eps = 1e-14, del = 0.992;const int MAXN = 1010;int N;double ansx, ansy, ans = 1e18;int x[MAXN], y[MAXN], w[MAXN];double calcEp(double nx, double ny)&#123; double ret = 0; for (int i = 1; i &lt;= N; i++) &#123; double dx = nx - x[i], dy = ny - y[i]; ret += sqrt(dx * dx + dy * dy) * (double)w[i]; &#125; return ret;&#125;void SA()&#123; double T = 1926, tx = ansx, ty = ansy; while (T &gt; eps) &#123; double nx = tx + ((rand() &lt;&lt; 1) - RAND_MAX) * T; double ny = ty + ((rand() &lt;&lt; 1) - RAND_MAX) * T; double c = calcEp(nx, ny); double d = c - ans; if (d &lt; eps) &#123;ansx = nx, ansy = ny; ans = c; tx = nx, ty = ny;&#125; else if (exp(-d / T) * RAND_MAX &gt; rand())&#123;tx = nx, ty = ny;&#125; T *= del; &#125;&#125;void calc()&#123; for (int i = 1; i &lt;= N; i++) ansx += x[i], ansy += y[i]; ansx /= N, ansy /= N; SA(); SA(); SA(); SA(); &#125;int main()&#123; srand(19260817); srand(rand()); scanf("%d", &amp;N); for (int i = 1; i &lt;= N; i++) scanf("%d%d%d", &amp;x[i], &amp;y[i], &amp;w[i]); calc(); printf("%.3lf %.3lf\n", ansx, ansy); return 0;&#125;]]></content>
  </entry>
</search>
